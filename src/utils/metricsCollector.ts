import { LogEntry } from '../types';

export interface MetricsData {
  totalLogsGenerated: number;
  logsPerSecond: number;
  generatorStats: Map<string, {
    count: number;
    lastGenerated: Date;
    isActive: boolean;
  }>;
  errorCount: number;
  startTime: Date;
  uptime: number;
}

export class MetricsCollector {
  private static instance: MetricsCollector;
  private totalLogsGenerated: number = 0;
  private generatorStats: Map<string, {
    count: number;
    lastGenerated: Date;
    isActive: boolean;
  }> = new Map();
  private errorCount: number = 0;
  private startTime: Date = new Date();
  private logsInLastSecond: number[] = [];
  private lastSecondTimestamp: number = Date.now();

  private constructor() {
    // Update logs per second calculation every second
    setInterval(() => {
      this.updateLogsPerSecond();
    }, 1000);
  }

  public static getInstance(): MetricsCollector {
    if (!MetricsCollector.instance) {
      MetricsCollector.instance = new MetricsCollector();
    }
    return MetricsCollector.instance;
  }

  public recordLogGenerated(log: LogEntry): void {
    this.totalLogsGenerated++;
    
    const generatorName = log.source?.name || 'unknown';
    const stats = this.generatorStats.get(generatorName) || {
      count: 0,
      lastGenerated: new Date(),
      isActive: true
    };
    
    stats.count++;
    stats.lastGenerated = new Date();
    stats.isActive = true;
    
    this.generatorStats.set(generatorName, stats);
    
    // Track logs for per-second calculation
    const now = Date.now();
    if (now - this.lastSecondTimestamp < 1000) {
      this.logsInLastSecond.push(now);
    }
  }

  public recordError(): void {
    this.errorCount++;
  }

  public setGeneratorActive(generatorName: string, isActive: boolean): void {
    const stats = this.generatorStats.get(generatorName);
    if (stats) {
      stats.isActive = isActive;
    }
  }

  private updateLogsPerSecond(): void {
    const now = Date.now();
    // Keep only logs from the last second
    this.logsInLastSecond = this.logsInLastSecond.filter(timestamp => 
      now - timestamp < 1000
    );
    this.lastSecondTimestamp = now;
  }

  public getMetrics(): MetricsData {
    const now = new Date();
    const uptime = Math.floor((now.getTime() - this.startTime.getTime()) / 1000);
    
    return {
      totalLogsGenerated: this.totalLogsGenerated,
      logsPerSecond: this.logsInLastSecond.length,
      generatorStats: new Map(this.generatorStats),
      errorCount: this.errorCount,
      startTime: this.startTime,
      uptime
    };
  }

  public getPrometheusMetrics(): string {
    const metrics = this.getMetrics();
    const lines: string[] = [];
    
    // Basic metrics
    lines.push('# HELP log_generator_logs_total Total number of logs generated');
    lines.push('# TYPE log_generator_logs_total counter');
    lines.push(`log_generator_logs_total ${metrics.totalLogsGenerated}`);
    
    lines.push('# HELP log_generator_logs_per_second Current logs per second');
    lines.push('# TYPE log_generator_logs_per_second gauge');
    lines.push(`log_generator_logs_per_second ${metrics.logsPerSecond}`);
    
    lines.push('# HELP log_generator_errors_total Total number of errors');
    lines.push('# TYPE log_generator_errors_total counter');
    lines.push(`log_generator_errors_total ${metrics.errorCount}`);
    
    lines.push('# HELP log_generator_uptime_seconds Uptime in seconds');
    lines.push('# TYPE log_generator_uptime_seconds gauge');
    lines.push(`log_generator_uptime_seconds ${metrics.uptime}`);
    
    // Generator-specific metrics
    lines.push('# HELP log_generator_by_source_total Logs generated by source');
    lines.push('# TYPE log_generator_by_source_total counter');
    
    metrics.generatorStats.forEach((stats, generatorName) => {
      lines.push(`log_generator_by_source_total{generator="${generatorName}"} ${stats.count}`);
    });
    
    lines.push('# HELP log_generator_active_generators Currently active generators');
    lines.push('# TYPE log_generator_active_generators gauge');
    
    metrics.generatorStats.forEach((stats, generatorName) => {
      lines.push(`log_generator_active_generators{generator="${generatorName}"} ${stats.isActive ? 1 : 0}`);
    });
    
    return lines.join('\n') + '\n';
  }

  public reset(): void {
    this.totalLogsGenerated = 0;
    this.generatorStats.clear();
    this.errorCount = 0;
    this.startTime = new Date();
    this.logsInLastSecond = [];
  }
}
