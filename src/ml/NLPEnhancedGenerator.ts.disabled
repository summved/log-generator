/**
 * NLP Enhanced Generator
 * Advanced log generator using NLP models for realistic message generation
 */

import { MLEnhancedLogGenerator } from './MLEnhancedLogGenerator';
import { MLModelManager } from './MLModelManager';
import { LogEntry, LogSource } from '../types';
import { EnhancedMLConfig, EnhancedLogContext, NLPAnalysisResult } from '../types/enhancedMlPatterns';
import { logger } from '../utils/logger';
import { timestampSequencer } from '../utils/timestampSequencer';

export class NLPEnhancedGenerator extends MLEnhancedLogGenerator {
  private modelManager: MLModelManager;
  private nlpConfig: EnhancedMLConfig['nlp'];
  private messageCache: Map<string, string> = new Map();

  constructor(
    source: LogSource,
    modelManager: MLModelManager,
    config: EnhancedMLConfig
  ) {
    super(source, modelManager as any, config);
    this.modelManager = modelManager;
    this.nlpConfig = config.nlp;
    
    logger.info(`NLP Enhanced Generator initialized for source: ${source.name}`, {
      nlpEnabled: this.nlpConfig.enabled,
      models: this.nlpConfig.models
    });
  }

  /**
   * Generate enhanced log entry with NLP capabilities
   */
  protected async generateLogEntry(): Promise<LogEntry> {
    const timestamp = timestampSequencer.getUniqueTimestamp();
    const context = this.createEnhancedContext();

    try {
      // Generate base log entry
      const baseLogEntry: LogEntry = {
        timestamp: timestamp,
        level: this.selectLogLevel(context),
        source: this.source,
        message: await this.generateNLPEnhancedMessage(context),
        metadata: await this.generateEnhancedMetadata(context)
      };

      // Add MITRE technique mapping
      this.addMitreTechnique(baseLogEntry, this.selectMLTemplate());

      // Enhance with NLP analysis if enabled
      if (this.nlpConfig.enabled) {
        await this.enhanceWithNLPAnalysis(baseLogEntry);
      }

      return baseLogEntry;

    } catch (error) {
      logger.warn(`NLP-enhanced generation failed, falling back to base generation`, {
        source: this.source.name,
        error: error instanceof Error ? error.message : String(error)
      });
      
      return super.generateLogEntry();
    }
  }

  /**
   * Generate NLP-enhanced message
   */
  private async generateNLPEnhancedMessage(context: EnhancedLogContext): Promise<string> {
    const cacheKey = this.createCacheKey(context);
    
    // Check cache first if enabled
    if (this.nlpConfig.cacheEnabled && this.messageCache.has(cacheKey)) {
      return this.messageCache.get(cacheKey)!;
    }

    let message: string;

    try {
      // Generate base message using patterns
      const baseMessage = await this.generateContextualBaseMessage(context);
      
      // Enhance with NLP model if available
      if (this.nlpConfig.models.textGeneration) {
        message = await this.enhanceMessageWithNLP(baseMessage, context);
      } else {
        message = baseMessage;
      }

      // Apply sentiment adjustment if needed
      message = await this.adjustMessageSentiment(message, context);

      // Cache the result
      if (this.nlpConfig.cacheEnabled) {
        this.messageCache.set(cacheKey, message);
        
        // Clean cache if it gets too large
        if (this.messageCache.size > 1000) {
          const firstKey = this.messageCache.keys().next().value;
          this.messageCache.delete(firstKey);
        }
      }

      return message;

    } catch (error) {
      logger.debug(`NLP message generation failed, using fallback`, error);
      return await this.generateContextualBaseMessage(context);
    }
  }

  /**
   * Generate contextual base message
   */
  private async generateContextualBaseMessage(context: EnhancedLogContext): Promise<string> {
    const hour = context.timestamp ? context.timestamp.getHours() : new Date().getHours();
    const isBusinessHours = context.businessContext?.workingHours ?? (hour >= 9 && hour <= 17);
    const riskLevel = context.businessContext?.riskLevel ?? 'low';

    const messageTemplates = this.getMessageTemplates(this.source.type, isBusinessHours, riskLevel);
    const template = messageTemplates[Math.floor(Math.random() * messageTemplates.length)];

    return this.interpolateTemplate(template, context);
  }

  /**
   * Get message templates based on source type and context
   */
  private getMessageTemplates(sourceType: string, isBusinessHours: boolean, riskLevel: string): string[] {
    const timeContext = isBusinessHours ? 'during business hours' : 'outside business hours';
    const riskContext = riskLevel === 'high' ? 'high-risk' : riskLevel === 'medium' ? 'medium-risk' : 'normal';

    const templates: Record<string, string[]> = {
      authentication: [
        `User authentication successful for {userId} from {sourceIP} ${timeContext}`,
        `Login attempt ${riskContext} operation for user {userId} via {userAgent}`,
        `Authentication event: {userId} accessed system ${timeContext} with {riskContext} profile`,
        `Successful logon for {userId} from workstation {sourceIP} during ${riskContext} session`,
        `User {userId} authenticated successfully using {authMethod} ${timeContext}`
      ],
      
      application: [
        `Application {applicationId} processed request from {userId} ${timeContext}`,
        `Business operation completed: {operation} by {userId} with {riskContext} privileges`,
        `Application event: {userId} performed {operation} ${timeContext} on {resource}`,
        `Service request processed for {userId} from {sourceIP} during ${riskContext} session`,
        `Application {applicationId} handled {operation} request ${timeContext}`
      ],
      
      firewall: [
        `Network traffic allowed from {sourceIP} to {destIP} on port {port} ${timeContext}`,
        `Firewall rule triggered: {action} traffic from {sourceIP} during ${riskContext} period`,
        `Connection established: {sourceIP}:{srcPort} -> {destIP}:{port} ${timeContext}`,
        `Network security event: {action} {protocol} traffic from {sourceIP}`,
        `Firewall policy applied: {action} connection from {sourceIP} ${timeContext}`
      ],
      
      system: [
        `System performance: CPU {cpuUsage}%, Memory {memoryUsage}% ${timeContext}`,
        `Service {serviceName} {action} ${timeContext} with {riskContext} priority`,
        `System event: {serviceName} {action} during ${riskContext} maintenance window`,
        `Resource utilization: {resource} at {usage}% ${timeContext}`,
        `System monitoring: {serviceName} status {status} ${timeContext}`
      ]
    };

    return templates[sourceType] || templates.system;
  }

  /**
   * Interpolate template with context values
   */
  private interpolateTemplate(template: string, context: EnhancedLogContext): string {
    let message = template;

    // Replace context placeholders
    const replacements: Record<string, string> = {
      '{userId}': context.userId || `user${Math.floor(Math.random() * 1000)}`,
      '{systemId}': context.systemId || `sys${Math.floor(Math.random() * 100)}`,
      '{applicationId}': context.applicationId || `app${Math.floor(Math.random() * 50)}`,
      '{sessionId}': context.sessionId || `sess_${Date.now()}`,
      '{sourceIP}': context.technicalContext?.sourceIP || this.generateRandomIP(),
      '{destIP}': this.generateRandomIP(),
      '{userAgent}': context.technicalContext?.userAgent || this.generateRandomUserAgent(),
      '{port}': String(context.technicalContext?.port || this.generateRandomPort()),
      '{srcPort}': String(Math.floor(Math.random() * 65535) + 1024),
      '{protocol}': context.technicalContext?.protocol || this.selectRandomProtocol(),
      '{authMethod}': this.selectRandomAuthMethod(),
      '{operation}': this.selectRandomOperation(),
      '{resource}': this.selectRandomResource(),
      '{serviceName}': this.selectRandomService(),
      '{action}': this.selectRandomAction(),
      '{status}': this.selectRandomStatus(),
      '{cpuUsage}': String(Math.floor(Math.random() * 80) + 10),
      '{memoryUsage}': String(Math.floor(Math.random() * 70) + 20),
      '{usage}': String(Math.floor(Math.random() * 90) + 10),
      '{resource}': this.selectRandomSystemResource()
    };

    for (const [placeholder, value] of Object.entries(replacements)) {
      message = message.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), value);
    }

    return message;
  }

  /**
   * Enhance message with NLP model
   */
  private async enhanceMessageWithNLP(baseMessage: string, context: EnhancedLogContext): Promise<string> {
    try {
      // For now, use rule-based enhancement
      // In a full implementation, this would use the loaded NLP model
      let enhancedMessage = baseMessage;

      // Add contextual enhancements based on business context
      if (context.businessContext) {
        enhancedMessage = this.addBusinessContextToMessage(enhancedMessage, context.businessContext);
      }

      // Add security context if present
      if (context.securityContext) {
        enhancedMessage = this.addSecurityContextToMessage(enhancedMessage, context.securityContext);
      }

      // Ensure proper grammar and structure
      enhancedMessage = this.improveMessageGrammar(enhancedMessage);

      return enhancedMessage;

    } catch (error) {
      logger.debug('NLP enhancement failed, using base message', error);
      return baseMessage;
    }
  }

  /**
   * Adjust message sentiment based on context
   */
  private async adjustMessageSentiment(message: string, context: EnhancedLogContext): Promise<string> {
    if (!this.nlpConfig.models.sentiment) {
      return message;
    }

    try {
      // Analyze current sentiment
      const analysis = await this.modelManager.analyzeText(message);
      
      // Adjust based on security context
      if (context.securityContext?.threatLevel === 'high' || context.securityContext?.threatLevel === 'critical') {
        if (analysis.sentiment.label === 'positive') {
          // Make message more neutral/concerning for high threat contexts
          message = message.replace(/successful/gi, 'completed')
                          .replace(/normal/gi, 'detected')
                          .replace(/good/gi, 'acceptable');
        }
      }

      return message;

    } catch (error) {
      logger.debug('Sentiment adjustment failed', error);
      return message;
    }
  }

  /**
   * Enhance log entry with NLP analysis
   */
  private async enhanceWithNLPAnalysis(logEntry: LogEntry): Promise<void> {
    try {
      const analysis = await this.modelManager.analyzeText(logEntry.message);
      
      if (!logEntry.metadata) {
        logEntry.metadata = {};
      }

      // Add NLP analysis to metadata
      logEntry.metadata.nlp_analysis = {
        sentiment: analysis.sentiment,
        keywords: analysis.keywords,
        topics: analysis.topics,
        entities: analysis.entities,
        confidence: analysis.confidence,
        readability: analysis.readability
      };

      // Add extracted entities as separate fields
      for (const entity of analysis.entities) {
        const fieldName = `extracted_${entity.label.toLowerCase()}`;
        if (!logEntry.metadata[fieldName]) {
          logEntry.metadata[fieldName] = [];
        }
        logEntry.metadata[fieldName].push(entity.text);
      }

    } catch (error) {
      logger.debug('NLP analysis enhancement failed', error);
    }
  }

  /**
   * Create enhanced context for log generation
   */
  private createEnhancedContext(): EnhancedLogContext {
    const now = new Date();
    const hour = now.getHours();
    const isBusinessHours = hour >= 9 && hour <= 17;

    return {
      userId: `user_${Math.floor(Math.random() * 1000)}`,
      systemId: `system_${Math.floor(Math.random() * 100)}`,
      applicationId: `app_${Math.floor(Math.random() * 50)}`,
      sessionId: `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: now,
      businessContext: {
        department: this.selectRandomDepartment(),
        role: this.selectRandomRole(),
        workingHours: isBusinessHours,
        riskLevel: this.selectRandomRiskLevel()
      },
      technicalContext: {
        sourceIP: this.generateRandomIP(),
        userAgent: this.generateRandomUserAgent(),
        protocol: this.selectRandomProtocol(),
        port: this.generateRandomPort()
      },
      securityContext: {
        threatLevel: this.selectRandomThreatLevel(),
        mitreMapping: this.selectRandomMitreMapping(),
        iocs: []
      }
    };
  }

  /**
   * Create cache key for message caching
   */
  private createCacheKey(context: EnhancedLogContext): string {
    const keyComponents = [
      this.source.type,
      context.businessContext?.department || 'unknown',
      context.businessContext?.riskLevel || 'low',
      context.businessContext?.workingHours ? 'business' : 'after-hours'
    ];
    
    return keyComponents.join('_');
  }

  // Helper methods for generating random values

  private generateRandomIP(): string {
    const networks = [
      () => `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      () => `10.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      () => `172.${16 + Math.floor(Math.random() * 16)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`
    ];
    
    return networks[Math.floor(Math.random() * networks.length)]();
  }

  private generateRandomUserAgent(): string {
    const userAgents = [
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15'
    ];
    
    return userAgents[Math.floor(Math.random() * userAgents.length)];
  }

  private generateRandomPort(): number {
    const commonPorts = [80, 443, 22, 23, 21, 25, 53, 110, 143, 993, 995, 3389, 5432, 3306, 8080, 8443];
    return commonPorts[Math.floor(Math.random() * commonPorts.length)];
  }

  private selectRandomProtocol(): string {
    const protocols = ['TCP', 'UDP', 'HTTP', 'HTTPS', 'SSH', 'FTP', 'SMTP'];
    return protocols[Math.floor(Math.random() * protocols.length)];
  }

  private selectRandomAuthMethod(): string {
    const methods = ['password', 'mfa', 'sso', 'certificate', 'biometric', 'token'];
    return methods[Math.floor(Math.random() * methods.length)];
  }

  private selectRandomOperation(): string {
    const operations = ['create', 'read', 'update', 'delete', 'execute', 'download', 'upload', 'share'];
    return operations[Math.floor(Math.random() * operations.length)];
  }

  private selectRandomResource(): string {
    const resources = ['document', 'file', 'database', 'service', 'application', 'system', 'network'];
    return resources[Math.floor(Math.random() * resources.length)];
  }

  private selectRandomService(): string {
    const services = ['web-server', 'database', 'auth-service', 'api-gateway', 'cache', 'queue', 'scheduler'];
    return services[Math.floor(Math.random() * services.length)];
  }

  private selectRandomAction(): string {
    const actions = ['started', 'stopped', 'restarted', 'updated', 'configured', 'monitored', 'backed-up'];
    return actions[Math.floor(Math.random() * actions.length)];
  }

  private selectRandomStatus(): string {
    const statuses = ['running', 'stopped', 'error', 'warning', 'healthy', 'degraded', 'maintenance'];
    return statuses[Math.floor(Math.random() * statuses.length)];
  }

  private selectRandomSystemResource(): string {
    const resources = ['CPU', 'memory', 'disk', 'network', 'process', 'thread', 'connection'];
    return resources[Math.floor(Math.random() * resources.length)];
  }

  private selectRandomDepartment(): string {
    const departments = ['finance', 'hr', 'it', 'sales', 'marketing', 'operations', 'legal', 'security'];
    return departments[Math.floor(Math.random() * departments.length)];
  }

  private selectRandomRole(): string {
    const roles = ['user', 'admin', 'manager', 'analyst', 'developer', 'operator', 'auditor'];
    return roles[Math.floor(Math.random() * roles.length)];
  }

  private selectRandomRiskLevel(): 'low' | 'medium' | 'high' {
    const levels: ('low' | 'medium' | 'high')[] = ['low', 'low', 'low', 'medium', 'medium', 'high']; // Weighted towards low
    return levels[Math.floor(Math.random() * levels.length)];
  }

  private selectRandomThreatLevel(): 'low' | 'medium' | 'high' | 'critical' {
    const levels: ('low' | 'medium' | 'high' | 'critical')[] = ['low', 'low', 'medium', 'high', 'critical'];
    return levels[Math.floor(Math.random() * levels.length)];
  }

  private selectRandomMitreMapping(): { technique: string; tactic: string } {
    const mappings = [
      { technique: 'T1078', tactic: 'TA0001' }, // Valid Accounts
      { technique: 'T1071', tactic: 'TA0011' }, // Application Layer Protocol
      { technique: 'T1059', tactic: 'TA0002' }, // Command and Scripting Interpreter
      { technique: 'T1110', tactic: 'TA0006' }, // Brute Force
      { technique: 'T1190', tactic: 'TA0001' }  // Exploit Public-Facing Application
    ];
    
    return mappings[Math.floor(Math.random() * mappings.length)];
  }

  private addBusinessContextToMessage(message: string, businessContext: any): string {
    // Add department-specific terminology
    const departmentTerms: Record<string, string[]> = {
      'finance': ['transaction', 'payment', 'invoice', 'budget', 'financial'],
      'hr': ['employee', 'payroll', 'benefits', 'recruitment', 'personnel'],
      'it': ['server', 'network', 'system', 'technical', 'infrastructure'],
      'sales': ['customer', 'lead', 'deal', 'revenue', 'opportunity'],
      'marketing': ['campaign', 'content', 'brand', 'engagement', 'analytics']
    };

    const terms = departmentTerms[businessContext.department];
    if (terms && Math.random() < 0.3) {
      const term = terms[Math.floor(Math.random() * terms.length)];
      message += ` (${term} related)`;
    }

    return message;
  }

  private addSecurityContextToMessage(message: string, securityContext: any): string {
    if (securityContext.threatLevel === 'high' || securityContext.threatLevel === 'critical') {
      message += ' - Security monitoring active';
    }

    return message;
  }

  private improveMessageGrammar(message: string): string {
    // Basic grammar improvements
    message = message.replace(/\s+/g, ' ').trim(); // Clean whitespace
    message = message.charAt(0).toUpperCase() + message.slice(1); // Capitalize first letter
    
    // Ensure proper punctuation
    if (!/[.!?]$/.test(message)) {
      message += '.';
    }

    return message;
  }
}

